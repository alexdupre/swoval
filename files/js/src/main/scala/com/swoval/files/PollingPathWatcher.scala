// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Filters.AllPass
import com.swoval.files.FileTreeDataViews.CacheObserver
import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.functional.Either
import java.io.IOException
import java.nio.file.NotDirectoryException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

class PollingPathWatcher(private val followLinks: Boolean, pollInterval: Long, timeUnit: TimeUnit)
    extends PathWatcher[PathWatchers.Event] {

  private val isClosed: AtomicBoolean = new AtomicBoolean(false)

  private val registry: DirectoryRegistry = new DirectoryRegistryImpl()

  private val observers: Observers[PathWatchers.Event] = new Observers()

  private var oldEntries: Map[Path, FileTreeDataViews.Entry[Path]] = getEntries

  private val periodicTask: PeriodicTask =
    new PeriodicTask(new PollingRunnable(), timeUnit.toMillis(pollInterval))

  private val converter: Converter[Path] = new Converter[Path]() {
    override def apply(typedPath: TypedPath): Path = typedPath.getPath
  }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    var result: Boolean = false
    val entries: List[FileTreeDataViews.Entry[Path]] =
      getEntries(path, maxDepth)
    this.synchronized {
      addAll(oldEntries, entries)
      result = registry.addDirectory(path, maxDepth)
    }
    Either.right(result)
  }

  override def unregister(path: Path): Unit = {
    registry.removeDirectory(path)
  }

  override def close(): Unit = {
    if (isClosed.compareAndSet(false, true)) {
      registry.close()
      try periodicTask.close()
      catch {
        case e: InterruptedException => e.printStackTrace(System.err)

      }
    }
  }

  override def addObserver(observer: Observer[_ >: PathWatchers.Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

  private def addAll(map: Map[Path, FileTreeDataViews.Entry[Path]],
                     list: List[FileTreeDataViews.Entry[Path]]): Unit = {
    val it: Iterator[FileTreeDataViews.Entry[Path]] = list.iterator()
    while (it.hasNext) {
      val entry: FileTreeDataViews.Entry[Path] = it.next()
      map.put(entry.getTypedPath.getPath, entry)
    }
  }

  private def getEntries(path: Path, maxDepth: Int): List[FileTreeDataViews.Entry[Path]] =
    try {
      val view: DirectoryDataView[Path] =
        FileTreeDataViews.cached(path, converter, maxDepth, followLinks)
      val entries: List[FileTreeDataViews.Entry[Path]] =
        view.listEntries(-1, AllPass)
      entries.addAll(view.listEntries(maxDepth, AllPass))
      entries
    } catch {
      case e: NotDirectoryException => {
        val result: List[FileTreeDataViews.Entry[Path]] =
          new ArrayList[FileTreeDataViews.Entry[Path]]()
        val typedPath: TypedPath = TypedPaths.get(path)
        result.add(Entries.get(typedPath, converter, typedPath))
        result
      }

      case e: IOException => Collections.emptyList()

    }

  private def getEntries(): Map[Path, FileTreeDataViews.Entry[Path]] = {
// I have to use putAll because scala.js doesn't handle new HashMap(registry.registered()).
    val map: HashMap[Path, Integer] = new HashMap[Path, Integer]()
    this.synchronized {
      map.putAll(registry.registered())
    }
    val it: Iterator[Entry[Path, Integer]] = map.entrySet().iterator()
    val result: Map[Path, FileTreeDataViews.Entry[Path]] =
      new HashMap[Path, FileTreeDataViews.Entry[Path]]()
    while (it.hasNext) {
      val entry: Entry[Path, Integer] = it.next()
      val entries: List[FileTreeDataViews.Entry[Path]] =
        getEntries(entry.getKey, entry.getValue)
      addAll(result, entries)
    }
    result
  }

  private class PollingRunnable extends Runnable {

    val cacheObserver: CacheObserver[Path] = new CacheObserver[Path]() {
      override def onCreate(newEntry: FileTreeDataViews.Entry[Path]): Unit = {
        observers.onNext(new Event(newEntry.getTypedPath, Kind.Create))
      }

      override def onDelete(oldEntry: FileTreeDataViews.Entry[Path]): Unit = {
        observers.onNext(new Event(oldEntry.getTypedPath, Kind.Delete))
      }

      override def onUpdate(oldEntry: FileTreeDataViews.Entry[Path],
                            newEntry: FileTreeDataViews.Entry[Path]): Unit = {
        observers.onNext(new Event(newEntry.getTypedPath, Kind.Modify))
      }

      override def onError(exception: IOException): Unit = {
        observers.onError(exception)
      }
    }

    override def run(): Unit = {
      val newEntries: Map[Path, FileTreeDataViews.Entry[Path]] = getEntries
      MapOps.diffDirectoryEntries(oldEntries, newEntries, cacheObserver)
      this.synchronized {
        oldEntries = newEntries
      }
    }

  }

}
