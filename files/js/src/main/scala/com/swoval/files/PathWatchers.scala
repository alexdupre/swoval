// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Consumer
import com.swoval.runtime.Platform
import java.io.IOException
import java.nio.file.Path

object PathWatchers {

  val DEFAULT_FACTORY: Factory = new Factory() {
    override def create(callback: Consumer[Event],
                        executor: Executor,
                        directoryRegistry: DirectoryRegistry): PathWatcher =
      get(callback, executor, directoryRegistry)
  }

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @param callback [[com.swoval.functional.Consumer]] to run on file events
   * @param options Runtime [[Option]] instances for the watcher. This is only relevant for the
   *     [[NioPathWatcher]] that is used on linux and windows.
   * @return PathWatcher for the runtime platform
   *     initialized
   */
  def get(callback: Consumer[Event], options: Option*): PathWatcher =
    get(callback,
        Executor.make("com.swoval.files.PathWatcher-internal-executor"),
        new DirectoryRegistry(),
        options: _*)

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @param callback [[Consumer]] to run on file events
   * @param executor provides a single threaded context to manage state
   * @param options Runtime [[Option]] instances for the watcher. This is only relevant for the
   *     [[NioPathWatcher]] that is used on linux and windows.
   * @return PathWatcher for the runtime platform
   *     initialized
   */
  def get(callback: Consumer[Event], executor: Executor, options: Option*): PathWatcher =
    get(callback, executor, new DirectoryRegistry(), options: _*)

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @param callback [[Consumer]] to run on file events
   * @param executor provides a single threaded context to manage state
   * @param registry The registry of directories to monitor
   * @param options Runtime [[Option]] instances for the watcher. This is only relevant for the
   *     [[NioPathWatcher]] that is used on linux and windows.
   * @return PathWatcher for the runtime platform
   *     initialized
   */
  def get(callback: Consumer[Event],
          executor: Executor,
          registry: DirectoryRegistry,
          options: Option*): PathWatcher =
    if (Platform.isMac)
      new ApplePathWatcher(callback, executor, registry, options: _*)
    else PlatformWatcher.make(callback, executor, registry, options: _*)

  /**
   * Instantiates new [[PathWatcher]] instances with a [[Consumer]]. This is primarily so
   * that the [[PathWatcher]] in [[FileCache]] may be changed in testing.
   */
  abstract class Factory {

    /**
     * Creates a new PathWatcher
     *
     * @param callback The callback to invoke on directory updates
     * @param executor The executor on which internal updates are invoked
     * @return A PathWatcher instance
     *     can occur on mac
     *     and windows
     */
    def create(callback: Consumer[Event], executor: Executor): PathWatcher =
      create(callback, executor, new DirectoryRegistry())

    /**
     * Creates a new PathWatcher
     *
     * @param callback The callback to invoke on directory updates
     * @param executor The executor on which internal updates are invoked
     * @param directoryRegistry The registry of directories to monitor
     * @return A PathWatcher instance
     *     can occur on mac
     *     and windows
     */
    def create(callback: Consumer[Event],
               executor: Executor,
               directoryRegistry: DirectoryRegistry): PathWatcher

  }

  /**
 Options for the PathWatcher.
   */
  class Option(private val name: String) {

    override def equals(obj: Any): Boolean = obj match {
      case obj: Option => obj.name == this.name
      case _           => false

    }

    override def hashCode(): Int = name.hashCode

    override def toString(): String = name

  }

  object Options {

    /**
     * Require that the PathWatcher poll newly created directories for files contained therein. A
     * creation event will be generated for any file found within the new directory. This is
     * somewhat expensive and may be redundant in some cases, see [[FileCache]] which does its
     * own polling for new directories.
     */
    val POLL_NEW_DIRECTORIES: Option = new Option("POLL_NEW_DIRECTORIES")

  }

  object Event {

    val Create: Kind = new Kind("Create", 1)

    val Delete: Kind = new Kind("Delete", 2)

    val Error: Kind = new Kind("Error", 4)

    val Modify: Kind = new Kind("Modify", 3)

    val Overflow: Kind = new Kind("Overflow", 0)

    /**
     * An enum like class to indicate the type of file event. It isn't an actual enum because the
     * scala.js codegen has problems with enum types.
     */
    class Kind(private val name: String, private val priority: Int) extends Comparable[Kind] {

      override def toString(): String = name

      override def equals(other: Any): Boolean = other match {
        case other: Kind => other.name == this.name
        case _           => false

      }

      override def hashCode(): Int = name.hashCode

      override def compareTo(that: Kind): Int =
        java.lang.Integer.compare(this.priority, that.priority)

    }

  }

  /**
 Container for [[PathWatcher]] events
   */
  class Event(val path: Path, val kind: Event.Kind) {

    override def equals(other: Any): Boolean = other match {
      case other: Event => {
        val that: Event = other
        this.path == that.path && this.kind == that.kind
      }
      case _ => false

    }

    override def hashCode(): Int = path.hashCode ^ kind.hashCode

    override def toString(): String = "Event(" + path + ", " + kind + ")"

  }

}
