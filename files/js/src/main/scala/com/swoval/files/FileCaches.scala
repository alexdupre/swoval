// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.PathWatchers.DEFAULT_FACTORY
import com.swoval.files.Directory.Converter
import com.swoval.files.Directory.Observer
import com.swoval.files.PathWatchers.Factory
import java.io.IOException
import Option._

object FileCaches {

  /**
   * Create a file cache.
   *
   * @param converter converts a path to the cached value type T
   * @param options options for the cache
   * @tparam T the value type of the cache entries
   * @return a file cache.
   */
  def get[T <: AnyRef](converter: Converter[T], options: Option*): FileCache[T] =
    new FileCacheImpl(converter, DEFAULT_FACTORY, null, options: _*)

  /**
   * Create a file cache with an Observer of events.
   *
   * @param converter converts a path to the cached value type T
   * @param observer observer of events for this cache
   * @param options options for the cache
   * @tparam T the value type of the cache entries
   * @return a file cache.
   */
  def get[T <: AnyRef](converter: Converter[T],
                       observer: Observer[T],
                       options: Option*): FileCache[T] = {
    val res: FileCache[T] =
      new FileCacheImpl[T](converter, DEFAULT_FACTORY, null, options: _*)
    res.addObserver(observer)
    res
  }

  /**
   * Create a file cache using a factory to provide an instance of[[com.swoval.files.PathWatcher]].
   *
   * @param converter converts a path to the cached value type T
   * @param factory creates a [[com.swoval.files.PathWatcher]]
   * @param options options for the cache
   * @tparam T The value type of the cache entries
   * @return A file cache
   */
  def get[T <: AnyRef](converter: Converter[T],
                       factory: PathWatchers.Factory,
                       options: Option*): FileCache[T] =
    new FileCacheImpl(converter, factory, null, options: _*)

  /**
   * Create a file cache with an Observer of events.
   *
   * @param converter converts a path to the cached value type T
   * @param factory a factory to create a path watcher
   * @param observer an observer of events for this cache
   * @param options options for the cache
   * @tparam T the value type of the cache entries
   * @return a file cache.
   */
  def get[T <: AnyRef](converter: Converter[T],
                       factory: Factory,
                       observer: Observer[T],
                       options: Option*): FileCache[T] = {
    val res: FileCache[T] =
      new FileCacheImpl[T](converter, factory, null, options: _*)
    res.addObserver(observer)
    res
  }

  object Option {

    /**
     * When the FileCache encounters a symbolic link with a path as target, treat the symbolic link
     * like a path. Note that it is possible to create a loop if two directories mutually link to
     * each other symbolically. When this happens, the FileCache will throw a [[java.nio.file.FileSystemLoopException]] when attempting to register one of these directories
     * or if the link that completes the loop is added to a registered path.
     */
    val NOFOLLOW_LINKS: FileCaches.Option = new Option()

  }

  /**
 Options for the implementation of a [[FileCache]].
   */
  class Option()

}
