// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.functional.Either
import com.swoval.functional.Filter
import java.io.IOException
import java.nio.file.Path
import java.util.Iterator

class SymlinkFollowingPathWatcher(private val pathWatcher: PathWatcher[PathWatchers.Event],
                                  directoryRegistry: DirectoryRegistry)
    extends PathWatcher[PathWatchers.Event] {

  private val symlinkWatcher: SymlinkWatcher = new SymlinkWatcher(
    PathWatchers.get(false, new DirectoryRegistryImpl()))

  private val observers: Observers[PathWatchers.Event] = new Observers()

  private val pathWatcherDirectoryRegistry: DirectoryRegistry =
    directoryRegistry

  pathWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      observers.onError(t)
    }

    override def onNext(event: Event): Unit = {
      if (event.exists() && event.isSymbolicLink) {
        try symlinkWatcher.addSymlink(event.getPath, directoryRegistry.maxDepthFor(event.getPath))
        catch {
          case e: IOException => observers.onError(e)

        }
      } else if (!event.exists()) {
        symlinkWatcher.remove(event.getPath)
      }
      observers.onNext(event)
    }
  })

  symlinkWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      observers.onError(t)
    }

    override def onNext(event: Event): Unit = {
      observers.onNext(event)
    }
  })

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    val pathWatcherResult: Either[IOException, Boolean] =
      pathWatcher.register(path, maxDepth)
    var listResult: Either[IOException, Boolean] = pathWatcherResult
    if (pathWatcherResult.isRight) {
      try {
        val it: Iterator[TypedPath] = FileTreeViews
          .list(path, maxDepth, new Filter[TypedPath]() {
            override def accept(typedPath: TypedPath): Boolean =
              typedPath.isSymbolicLink
          })
          .iterator()
        while (it.hasNext) {
          val p: Path = it.next().getPath
          symlinkWatcher.addSymlink(p, pathWatcherDirectoryRegistry.maxDepthFor(p))
        }
        listResult = Either.right(true)
      } catch {
        case e: IOException => listResult = Either.left(e)

      }
    }
    listResult
  }

  override def unregister(path: Path): Unit = {
    try {
      val it: Iterator[TypedPath] = FileTreeViews
        .list(path, pathWatcherDirectoryRegistry.maxDepthFor(path), new Filter[TypedPath]() {
          override def accept(typedPath: TypedPath): Boolean =
            typedPath.isSymbolicLink
        })
        .iterator()
      while (it.hasNext) symlinkWatcher.remove(it.next().getPath)
    } catch {
      case e: IOException => {}

    }
    pathWatcher.unregister(path)
  }

  override def close(): Unit = {
    pathWatcher.close()
    symlinkWatcher.close()
  }

  override def addObserver(observer: Observer[PathWatchers.Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

}
