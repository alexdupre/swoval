// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.util.Map.Entry
import com.swoval.functional.Filter
import java.nio.file.Path
import java.util.Collections
import java.util.HashMap
import java.util.Iterator
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import DirectoryRegistryImpl._

trait DirectoryRegistry extends Filter[Path] with AutoCloseable {

  def addDirectory(path: Path, maxDepth: Int): Boolean

  def maxDepthFor(path: Path): Int

  def registered(): Map[Path, Integer]

  def removeDirectory(path: Path): Unit

  def acceptPrefix(path: Path): Boolean

  override def close(): Unit

}

object DirectoryRegistries {

  def toTypedPathFilter(registry: DirectoryRegistry): Filter[TypedPath] =
    new Filter[TypedPath]() {
      override def accept(typedPath: TypedPath): Boolean =
        registry.accept(typedPath.getPath)
    }

}

object DirectoryRegistryImpl {

  private class RegisteredDirectory(val path: Path, val maxDepth: Int) {

    val compMaxDepth: Int =
      if (maxDepth == java.lang.Integer.MAX_VALUE) maxDepth else maxDepth + 1

    def accept(path: Path): Boolean =
      path.startsWith(this.path) &&
        (path == this.path ||
          this.path.relativize(path).getNameCount <= compMaxDepth)

    override def toString(): String =
      "RegisteredDirectory(path = " + path + ", depth = " +
        maxDepth +
        ")"

  }

}

class DirectoryRegistryImpl extends DirectoryRegistry {

  private val registeredDirectoriesByPath: LockableMap[Path, RegisteredDirectory] =
    new LockableMap(new ConcurrentHashMap[Path, RegisteredDirectory]())

  override def addDirectory(path: Path, maxDepth: Int): Boolean =
    if (registeredDirectoriesByPath.lock()) {
      try {
        val registeredDirectory: RegisteredDirectory =
          registeredDirectoriesByPath.get(path)
        if (registeredDirectory == null || maxDepth > registeredDirectory.maxDepth) {
          registeredDirectoriesByPath.put(path, new RegisteredDirectory(path, maxDepth))
          true
        } else {
          false
        }
      } finally registeredDirectoriesByPath.unlock()
    } else {
      false
    }

  override def maxDepthFor(path: Path): Int =
    if (registeredDirectoriesByPath.lock()) {
      try {
        var maxDepth: Int = java.lang.Integer.MIN_VALUE
        val it: Iterator[RegisteredDirectory] =
          registeredDirectoriesByPath.values.iterator()
        while (it.hasNext) {
          val dir: RegisteredDirectory = it.next()
          if (path.startsWith(dir.path)) {
            val depth: Int =
              if (dir.path == path) 0
              else dir.path.relativize(path).getNameCount
            val possibleMaxDepth: Int = dir.maxDepth - depth
            if (possibleMaxDepth > maxDepth) {
              maxDepth = possibleMaxDepth
            }
          }
        }
        maxDepth
      } finally registeredDirectoriesByPath.unlock()
    } else {
      -1
    }

  override def registered(): Map[Path, Integer] =
    if (registeredDirectoriesByPath.lock()) {
      try {
        val result: Map[Path, Integer] = new HashMap[Path, Integer]()
        val it: Iterator[RegisteredDirectory] =
          registeredDirectoriesByPath.values.iterator()
        while (it.hasNext) {
          val dir: RegisteredDirectory = it.next()
          result.put(dir.path, dir.maxDepth)
        }
        result
      } finally registeredDirectoriesByPath.unlock()
    } else {
      Collections.emptyMap()
    }

  override def removeDirectory(path: Path): Unit = {
    if (registeredDirectoriesByPath.lock()) {
      try registeredDirectoriesByPath.remove(path)
      finally registeredDirectoriesByPath.unlock()
    }
  }

  private def acceptImpl(path: Path, acceptPrefix: Boolean): Boolean =
    if (registeredDirectoriesByPath.lock()) {
      try {
        var result: Boolean = false
        val it: Iterator[Entry[Path, RegisteredDirectory]] =
          registeredDirectoriesByPath.iterator()
        while (!result && it.hasNext) {
          val entry: Entry[Path, RegisteredDirectory] = it.next()
          val registeredDirectory: RegisteredDirectory = entry.getValue
          val watchPath: Path = entry.getKey
          if (acceptPrefix && watchPath.startsWith(path)) {
            result = true
          } else if (path.startsWith(watchPath)) {
            result = registeredDirectory.accept(path)
          }
        }
        result
      } finally registeredDirectoriesByPath.unlock()
    } else {
      false
    }

  override def accept(path: Path): Boolean = acceptImpl(path, false)

  override def acceptPrefix(path: Path): Boolean = acceptImpl(path, true)

  override def close(): Unit = {
    registeredDirectoriesByPath.clear()
  }

}
