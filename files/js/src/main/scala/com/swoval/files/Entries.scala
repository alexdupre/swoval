// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Either.leftProjection
import com.swoval.files.Directory.Converter
import com.swoval.files.Directory.Entry
import com.swoval.functional.Either
import java.io.IOException
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.attribute.BasicFileAttributes
import scala.beans.{ BeanProperty, BooleanBeanProperty }

object Entries {

  val DIRECTORY: Int = 1

  val FILE: Int = 2

  val LINK: Int = 4

  val UNKNOWN: Int = 8

  def get[T](path: Path, kind: Int, converter: Converter[T], converterPath: Path): Entry[T] =
    try new ValidEntry(path, kind, converter.apply(converterPath))
    catch {
      case e: IOException => new InvalidEntry(path, kind, e)

    }

  def resolve[T](path: Path, entry: Entry[T]): Entry[T] = {
    val value: Either[IOException, T] = entry.getValue
    val kind: Int = getKind(entry)
    if (value.isRight)
      new ValidEntry(path.resolve(entry.getPath), kind, value.get)
    else
      new InvalidEntry[T](path.resolve(entry.getPath), kind, leftProjection(value).getValue)
  }

  private def getKind(entry: Entry[_]): Int =
    (if (entry.isSymbolicLink) LINK else 0) | (if (entry.isDirectory) DIRECTORY
                                               else 0) |
      (if (entry.isFile) FILE else 0)

  /**
   * Compute the underlying file type for the path.
   *
   * @param path The path whose type is to be determined.
   * @param attrs The attributes of the ile
   * @return The file type of the path
   */
  def getKind(path: Path, attrs: BasicFileAttributes): Int =
    if (attrs.isSymbolicLink)
      LINK | (if (Files.isDirectory(path)) DIRECTORY else FILE)
    else if (attrs.isDirectory) DIRECTORY
    else FILE

  /**
   * Compute the underlying file type for the path.
   *
   * @param path The path whose type is to be determined.
   * @return The file type of the path
   */
  def getKind(path: Path): Int =
    getKind(path, NioWrappers.readAttributes(path, LinkOption.NOFOLLOW_LINKS))

  private abstract class EntryImpl[T](@BeanProperty val path: Path, private val kind: Int)
      extends Entry[T] {

    override def isDirectory(): Boolean =
      is(Entries.DIRECTORY) || (is(Entries.UNKNOWN) && Files.isDirectory(path))

    override def isFile(): Boolean =
      is(Entries.FILE) || (is(Entries.UNKNOWN) && Files.isRegularFile(path))

    override def isSymbolicLink(): Boolean =
      is(Entries.LINK) || (is(Entries.UNKNOWN) && Files.isRegularFile(path))

    private def is(kind: Int): Boolean = (kind & this.kind) != 0

    override def hashCode(): Int = {
      val value: Int =
        com.swoval.functional.Either.getOrElse(getValue, 0).hashCode
      path.hashCode ^ value
    }

    override def equals(other: Any): Boolean =
      other.isInstanceOf[Entry[_]] && other
        .asInstanceOf[Entry[_]]
        .getPath == getPath &&
        getValue == other.asInstanceOf[Entry[_]].getValue

  }

  private class ValidEntry[T](path: Path, kind: Int, private val value: T)
      extends EntryImpl[T](path, kind) {

    override def getValue(): Either[IOException, T] = Either.right(value)

    override def toString(): String =
      "ValidEntry(" + getPath + ", " + value + ")"

  }

  private class InvalidEntry[T](path: Path, kind: Int, private val exception: IOException)
      extends EntryImpl[T](path, kind) {

    override def getValue(): Either[IOException, T] = Either.left(exception)

    override def toString(): String =
      "InvalidEntry(" + getPath + ", " + exception + ")"

  }

}
