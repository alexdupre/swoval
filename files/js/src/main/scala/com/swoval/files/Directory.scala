// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.EntryFilters.AllPass
import com.swoval.functional.Either.leftProjection
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.functional.Filters
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Collection
import java.util.HashMap
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.concurrent.atomic.AtomicReference
import Directory._
import scala.beans.{ BeanProperty, BooleanBeanProperty }

object Directory {

  /**
   * Converts a Path into an arbitrary value to be cached.
   *
   * @tparam R the generic type generated from the path.
   */
  trait Converter[R] {

    /**
     * Convert the path to a value.
     *
     * @param path the path to convert
     * @return the converted value
     */
    def apply(path: Path): R

  }

  /**
   * Container class for [[Directory]] entries. Contains both the path to which the path
   * corresponds along with a data value.
   *
   * @tparam T The value wrapped in the Entry
   */
  trait Entry[T] extends TypedPath {

    /**
     * Return the value associated with this entry.
     *
     * @return the value associated with this entry.
     */
    def getValue(): Either[IOException, T]

    /**
     * Return the path associated with this entry.
     *
     * @return the path associated with this entry.
     */
    def getPath(): Path

  }

  class Updates[T] extends Observer[T] {

    private val creations: List[Entry[T]] = new ArrayList()

    private val deletions: List[Entry[T]] = new ArrayList()

    private val updates: List[Array[Entry[T]]] = new ArrayList()

    def observe(observer: Observer[T]): Unit = {
      val creationIterator: Iterator[Entry[T]] = creations.iterator()
      while (creationIterator.hasNext) observer.onCreate(creationIterator.next())
      val updateIterator: Iterator[Array[Entry[T]]] = updates.iterator()
      while (updateIterator.hasNext) {
        val entries: Array[Entry[T]] = updateIterator.next()
        observer.onUpdate(entries(0), entries(1))
      }
      val deletionIterator: Iterator[Entry[T]] = deletions.iterator()
      while (deletionIterator.hasNext) observer.onDelete(deletionIterator.next())
    }

    override def onCreate(newEntry: Entry[T]): Unit = {
      creations.add(newEntry)
    }

    override def onDelete(oldEntry: Entry[T]): Unit = {
      deletions.add(oldEntry)
    }

    override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
      updates.add(Array(oldEntry, newEntry))
    }

    override def onError(path: Path, exception: IOException): Unit = {}

  }

  /**
   * A Filter for [[Directory.Entry]] elements.
   *
   * @tparam T the data value type for the [[Directory.Entry]]
   */
  trait EntryFilter[T] {

    /**
     * Evaluates the filter for a given entry.
     *
     * @param entry the entry type
     * @return true if the [[com.swoval.files.Directory.Entry]] is accepted.
     */
    def accept(entry: Entry[_ <: T]): Boolean

  }

  /**
   * A callback to fire when a file in a monitored directory is created or deleted.
   *
   * @tparam T The cached value associated with the path
   */
  trait OnChange[T] {

    /**
     * The callback to run when the path changes.
     *
     * @param entry the entry for the updated path
     */
    def apply(entry: Entry[T]): Unit

  }

  /**
   * A callback to fire when a file in a monitor is updated.
   *
   * @tparam T the cached value associated with the path
   */
  trait OnUpdate[T] {

    /**
     * The callback to run when a path is updated.
     *
     * @param oldEntry the previous entry for the updated path
     * @param newEntry the new entry for the updated path
     */
    def apply(oldEntry: Entry[T], newEntry: Entry[T]): Unit

  }

  /**
   * A callback to fire when an error is encountered. This will generally be a [[java.nio.file.FileSystemLoopException]].
   */
  trait OnError {

    /**
     * Apply callback for error.
     *
     * @param path the path that induced the error
     * @param exception the encountered error
     */
    def apply(path: Path, exception: IOException): Unit

  }

  /**
   * Provides callbacks to run when different types of file events are detected by the cache.
   *
   * @tparam T the type for the [[Directory.Entry]] data
   */
  trait Observer[T] {

    /**
     * Callback to fire when a new path is created.
     *
     * @param newEntry the [[com.swoval.files.Directory.Entry]] for the newly created file
     */
    def onCreate(newEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is deleted.
     *
     * @param oldEntry the [[com.swoval.files.Directory.Entry]] for the deleted.
     */
    def onDelete(oldEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is modified.
     *
     * @param oldEntry the [[com.swoval.files.Directory.Entry]] for the updated path
     * @param newEntry the [[com.swoval.files.Directory.Entry]] for the deleted path
     */
    def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit

    /**
     * Callback to fire when an error is encountered generating while updating a path.
     *
     * @param path The path that triggered the exception
     * @param exception The exception thrown by the computation
     */
    def onError(path: Path, exception: IOException): Unit

  }

}

/**
 * Provides a mutable in-memory cache of files and subdirectories with basic CRUD functionality. The
 * Directory can be fully recursive as the subdirectories are themselves stored as recursive (when
 * the Directory is initialized without the recursive toggle, the subdirectories are stored as
 * [[Directory.Entry]] instances. The primary use case is the implementation of [[FileCache]] and [[NioPathWatcher]]. Directly handling Directory instances is discouraged
 * because it is inherently mutable so it's better to let the FileCache manage it and query the
 * cache rather than Directory directly.
 *
 * <p>The Directory should cache all of the files and subdirectories up the maximum depth. A maximum
 * depth of zero means that the Directory should cache the subdirectories, but not traverse them. A
 * depth {@code < 0} means that it should not cache any files or subdirectories within the
 * directory. In the event that a loop is created by symlinks, the Directory will include the
 * symlink that completes the loop, but will not descend further (inducing a loop).
 *
 * @tparam T the cache value type.
 */
class Directory[T <: AnyRef](@BeanProperty val path: Path,
                             private val realPath: Path,
                             private val converter: Converter[T],
                             private val depth: Int,
                             filter: Filter[_ >: QuickFile])
    extends DataRepository[T]
    with DirectoryRepository
    with AutoCloseable {

  def getMaxDepth(): Int = depth

  override def list(maxDepth: Int, filter: Filter[_ >: Path]): List[Path] =
    list(path, maxDepth, filter)

  private val _cacheEntry: AtomicReference[Entry[T]] = new AtomicReference(null)

  private val lock: AnyRef = new AnyRef()

  private val subdirectories: Map[Path, Directory[T]] = new HashMap()

  private val files: Map[Path, Entry[T]] = new HashMap()

  private val pathFilter: Filter[QuickFile] = new Filter[QuickFile]() {
    override def accept(quickFile: QuickFile): Boolean =
      quickFile.toPath().startsWith(Directory.this.path) && filter.accept(quickFile)
  }

  override def close(): Unit = {
    this.lock.synchronized {
      val it: Iterator[Directory[T]] = subdirectories.values.iterator()
      while (it.hasNext) it.next().close()
      subdirectories.clear()
      files.clear()
    }
  }

  override def list(path: Path, maxDepth: Int, filter: Filter[_ >: Path]): List[Path] = {
    val it: Iterator[Entry[T]] = list(path, maxDepth, new EntryFilter[T]() {
      override def accept(entry: Entry[_ <: T]): Boolean =
        filter.accept(entry.getPath)
    }).iterator()
    val result: List[Path] = new ArrayList[Path]()
    while (it.hasNext) result.add(it.next().getPath)
    result
  }

  /**
   * List all of the files for the {@code path</code> that are accepted by the <code>filter}.
   *
   * @param path the path to list. If this is a file, returns a list containing the Entry for the
   *     file or an empty list if the file is not monitored by the path.
   * @param maxDepth the maximum depth of subdirectories to return
   * @param filter include only paths accepted by this
   * @return a List of Entry instances accepted by the filter. The list will be empty if the path is
   *     not a subdirectory of this Directory or if it is a subdirectory, but the Directory was
   *     created without the recursive flag.
   */
  override def list(path: Path, maxDepth: Int, filter: EntryFilter[_ >: T]): List[Entry[T]] = {
    val findResult: Either[Entry[T], Directory[T]] = find(path)
    if (findResult != null) {
      if (findResult.isRight) {
        val result: List[Entry[T]] = new ArrayList[Entry[T]]()
        findResult.get.listImpl(maxDepth, filter, result)
        result
      } else {
        val entry: Entry[T] = leftProjection(findResult).getValue
        val result: List[Entry[T]] = new ArrayList[Entry[T]]()
        if (entry != null && filter.accept(entry)) result.add(entry)
        result
      }
    } else {
      new ArrayList()
    }
  }

  def list(maxDepth: Int, filter: EntryFilter[_ >: T]): List[Entry[T]] =
    list(getPath, maxDepth, filter)

  /**
   * The cache entry for the underlying path of this directory.
   *
   * @return the Entry for the directory itself.
   */
  def entry(): Entry[T] = _cacheEntry.get

  val kind: Int = Entries.getKind(path)

  this._cacheEntry.set(Entries.get(path, kind, converter, realPath))

  /**
   * Updates the Directory entry for a particular path.
   *
   * @param path the path to update
   * @param kind specifies the type of file. This can be DIRECTORY, FILE with an optional LINK bit
   *     set if the file is a symbolic link
   * @return a list of updates for the path. When the path is new, the updates have the
   *     oldCachedPath field set to null and will contain all of the children of the new path when
   *     it is a directory. For an existing path, the List contains a single Updates that contains
   *     the previous and new [[Directory.Entry]].
   *     traversing the directory.
   */
  def update(path: Path, kind: Int): Updates[T] =
    if (pathFilter.accept(new QuickFileImpl(path.toString, kind)))
      updateImpl(if (path == this.path) new ArrayList[Path]()
                 else FileOps.parts(this.path.relativize(path)),
                 kind)
    else new Updates[T]()

  /**
   * Remove a path from the directory.
   *
   * @param path the path to remove
   * @return a List containing the Entry instances for the removed path. The result also contains
   *     the cache entries for any children of the path when the path is a non-empty directory.
   */
  def remove(path: Path): List[Entry[T]] =
    if (path.isAbsolute && path.startsWith(this.path)) {
      removeImpl(FileOps.parts(this.path.relativize(path)))
    } else {
      new ArrayList()
    }

  override def toString(): String =
    "Directory(" + path + ", maxDepth = " + depth + ")"

  private def subdirectoryDepth(): Int =
    if (depth == java.lang.Integer.MAX_VALUE) depth
    else if (depth > 0) depth - 1
    else 0

  private def addDirectory(currentDir: Directory[T], path: Path, updates: Updates[T]): Unit = {
    val dir: Directory[T] =
      new Directory(path, path, converter, currentDir.subdirectoryDepth(), pathFilter).init()
    val oldEntries: Map[Path, Entry[T]] = new HashMap[Path, Entry[T]]()
    val previous: Directory[T] =
      currentDir.subdirectories.put(path.getFileName, dir)
    if (previous != null) {
      oldEntries.put(previous.realPath, previous.entry())
      val entryIterator: Iterator[Entry[T]] =
        previous.list(java.lang.Integer.MAX_VALUE, AllPass).iterator()
      while (entryIterator.hasNext) {
        val entry: Entry[T] = entryIterator.next()
        oldEntries.put(entry.getPath, entry)
      }
    }
    val newEntries: Map[Path, Entry[T]] = new HashMap[Path, Entry[T]]()
    newEntries.put(dir.realPath, dir.entry())
    val it: Iterator[Entry[T]] =
      dir.list(java.lang.Integer.MAX_VALUE, AllPass).iterator()
    while (it.hasNext) {
      val entry: Entry[T] = it.next()
      newEntries.put(entry.getPath, entry)
    }
    MapOps.diffDirectoryEntries(oldEntries, newEntries, updates)
  }

  private def isLoop(path: Path, realPath: Path): Boolean =
    path.startsWith(realPath) && path != realPath

  private def updateImpl(parts: List[Path], kind: Int): Updates[T] = {
    val result: Updates[T] = new Updates[T]()
    if (!parts.isEmpty) {
      val it: Iterator[Path] = parts.iterator()
      var currentDir: Directory[T] = this
      while (it.hasNext && currentDir != null && currentDir.depth >= 0) {
        val p: Path = it.next()
        if (p.toString.isEmpty) result
        val resolved: Path = currentDir.path.resolve(p)
        val realPath: Path = toRealPath(resolved)
        if (!it.hasNext) {
// We will always return from this block
          currentDir.lock.synchronized {
            val isDirectory: Boolean = (kind & Entries.DIRECTORY) != 0
            if (!isDirectory || currentDir.depth <= 0 || isLoop(resolved, realPath)) {
              val previousDirectory: Directory[T] =
                if (isDirectory) currentDir.subdirectories.get(p) else null
              val oldEntry: Entry[T] =
                if (previousDirectory != null) previousDirectory.entry()
                else currentDir.files.get(p)
              val newEntry: Entry[T] =
                Entries.get(p, kind, converter, resolved)
              if (isDirectory) {
                currentDir.subdirectories
                  .put(p, new Directory(resolved, realPath, converter, -1, pathFilter))
              } else {
                currentDir.files.put(p, newEntry)
              }
              val oldResolvedEntry: Entry[T] =
                if (oldEntry == null) null
                else Entries.resolve(currentDir.path, oldEntry)
              if (oldResolvedEntry == null) {
                result.onCreate(Entries.resolve(currentDir.path, newEntry))
              } else {
                result.onUpdate(oldResolvedEntry, Entries.resolve(currentDir.path, newEntry))
              }
              result
            } else {
              addDirectory(currentDir, resolved, result)
              result
            }
          }
        } else {
          currentDir.lock.synchronized {
            val dir: Directory[T] = currentDir.subdirectories.get(p)
            if (dir == null && currentDir.depth > 0) {
              addDirectory(currentDir, currentDir.path.resolve(p), result)
            }
            currentDir = dir
          }
        }
      }
    } else if (kind == Entries.DIRECTORY) {
      val oldEntries: List[Entry[T]] = list(getMaxDepth, AllPass)
      init()
      MapOps.diffDirectoryEntries(oldEntries, list(getMaxDepth, AllPass), result)
    } else {
      val oldEntry: Entry[T] = entry()
      val newEntry: Entry[T] = Entries.get(realPath, kind, converter, realPath)
      _cacheEntry.set(newEntry)
      result.onUpdate(oldEntry, entry())
    }
    result
  }

  private def findImpl(parts: List[Path]): Either[Entry[T], Directory[T]] = {
    val it: Iterator[Path] = parts.iterator()
    var currentDir: Directory[T] = this
    var result: Either[Entry[T], Directory[T]] = null
    while (it.hasNext && currentDir != null && result == null) {
      val p: Path = it.next()
      if (!it.hasNext) {
        currentDir.lock.synchronized {
          val subdir: Directory[T] = currentDir.subdirectories.get(p)
          if (subdir != null) {
            result = Either.right(subdir)
          } else {
            val entry: Entry[T] = currentDir.files.get(p)
            if (entry != null)
              result = Either.left(Entries.resolve(currentDir.path, entry))
          }
        }
      } else {
        currentDir.lock.synchronized {
          currentDir = currentDir.subdirectories.get(p)
        }
      }
    }
    result
  }

  private def find(path: Path): Either[Entry[T], Directory[T]] =
    if (path == this.path) {
      Either.right(this)
    } else if (!path.isAbsolute) {
      findImpl(FileOps.parts(path))
    } else if (path.startsWith(this.path)) {
      findImpl(FileOps.parts(this.path.relativize(path)))
    } else {
      null
    }

  private def listImpl(maxDepth: Int, filter: EntryFilter[_ >: T], result: List[Entry[T]]): Unit = {
    if (this.depth < 0 || maxDepth < 0) {
      result.add(this.entry())
    } else {
      var files: Collection[Entry[T]] = null
      var subdirectories: Collection[Directory[T]] = null
      this.lock.synchronized {
        files = new ArrayList(this.files.values)
        subdirectories = new ArrayList(this.subdirectories.values)
      }
      val filesIterator: Iterator[Entry[T]] = files.iterator()
      while (filesIterator.hasNext) {
        val entry: Entry[T] = filesIterator.next()
        val resolved: Entry[T] = Entries.resolve(getPath, entry)
        if (filter.accept(resolved)) result.add(resolved)
      }
      val subdirIterator: Iterator[Directory[T]] = subdirectories.iterator()
      while (subdirIterator.hasNext) {
        val subdir: Directory[T] = subdirIterator.next()
        val entry: Entry[T] = subdir.entry()
        val resolved: Entry[T] = Entries.resolve(getPath, entry)
        if (filter.accept(resolved)) result.add(resolved)
        if (maxDepth > 0) subdir.listImpl(maxDepth - 1, filter, result)
      }
    }
  }

  private def removeImpl(parts: List[Path]): List[Entry[T]] = {
    val result: List[Entry[T]] = new ArrayList[Entry[T]]()
    val it: Iterator[Path] = parts.iterator()
    var currentDir: Directory[T] = this
    while (it.hasNext && currentDir != null) {
      val p: Path = it.next()
      if (!it.hasNext) {
        currentDir.lock.synchronized {
          val entry: Entry[T] = currentDir.files.remove(p)
          if (entry != null) {
            result.add(Entries.resolve(currentDir.path, entry))
          } else {
            val dir: Directory[T] = currentDir.subdirectories.remove(p)
            if (dir != null) {
              result.addAll(dir.list(java.lang.Integer.MAX_VALUE, AllPass))
              result.add(dir.entry())
            }
          }
        }
      } else {
        currentDir.lock.synchronized {
          currentDir = currentDir.subdirectories.get(p)
        }
      }
    }
    result
  }

  private def toRealPath(path: Path): Path =
    try path.toRealPath()
    catch {
      case e: IOException => path

    }

  def init(): Directory[T] = {
    if (depth >= 0) {
      lock.synchronized {
        val it: Iterator[QuickFile] = QuickList.list(path, 0, true).iterator()
        while (it.hasNext) {
          val file: QuickFile = it.next()
          if (pathFilter.accept(file)) {
            val kind: Int = (if (file.isSymbolicLink) Entries.LINK else 0) |
              (if (file.isDirectory) Entries.DIRECTORY else Entries.FILE)
            val path: Path = file.toPath()
            val key: Path = this.path.relativize(path).getFileName
            if (file.isDirectory) {
              if (depth > 0) {
                val realPath: Path = toRealPath(path)
                if (!file.isSymbolicLink || !isLoop(path, realPath)) {
                  val dir: Directory[T] =
                    new Directory[T](path, realPath, converter, subdirectoryDepth(), pathFilter)
                  subdirectories.put(key, dir)
                  try dir.init()
                  catch {
                    case e: IOException => {}

                  }
                } else {
                  subdirectories.put(key, new Directory(path, realPath, converter, -1, pathFilter))
                }
              } else {
                files.put(key, Entries.get(key, kind, converter, path))
              }
            } else {
              files.put(key, Entries.get(key, kind, converter, path))
            }
          }
        }
      }
    }
    this
  }

}
