// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Consumer
import com.swoval.functional.Either
import com.swoval.runtime.Platform
import java.io.IOException
import java.nio.file.Path
import DirectoryWatcher._

object DirectoryWatcher {

  /**
   * Create a DirectoryWatcher for the runtime platform.
   *
   * @param callback [[com.swoval.functional.Consumer]] to run on file events
   * @param executor provides a single threaded context to manage state
   * @param options Runtime [[DirectoryWatcher.Option]] instances for the watcher. This is only
   *     relevant for the [[NioDirectoryWatcher]] that is used on linux and windows.
   * @return DirectoryWatcher for the runtime platform
   *     initialized
   *     initialization
   */
  def defaultWatcher(callback: Consumer[DirectoryWatcher.Event],
                     executor: Executor,
                     options: Option*): DirectoryWatcher =
    if (Platform.isMac) new AppleDirectoryWatcher(callback, executor, options: _*)
    else PlatformWatcher.make(callback, executor, options: _*)

  /**
   * Instantiates new [[DirectoryWatcher]] instances with a [[com.swoval.functional.Consumer]]. This is primarily so that the [[DirectoryWatcher]] in
   * [[FileCache]] may be changed in testing.
   */
  trait Factory {

    /**
     * Creates a new DirectoryWatcher
     *
     * @param callback The callback to invoke on directory updates
     * @param executor The executor on which internal updates are invoked
     * @return A DirectoryWatcher instance
     *     this can occur on mac
     *     and windows
     */
    def create(callback: Consumer[DirectoryWatcher.Event], executor: Executor): DirectoryWatcher

  }

  val DEFAULT_FACTORY: Factory = new Factory() {
    override def create(callback: Consumer[DirectoryWatcher.Event],
                        executor: Executor): DirectoryWatcher =
      defaultWatcher(callback, executor)
  }

  object Event {

    val Create: Kind = new Kind("Create", 1)

    val Delete: Kind = new Kind("Delete", 2)

    val Error: Kind = new Kind("Error", 4)

    val Modify: Kind = new Kind("Modify", 3)

    val Overflow: Kind = new Kind("Overflow", 0)

    /**
     * An enum like class to indicate the type of file event. It isn't an actual enum because the
     * scala.js codegen has problems with enum types.
     */
    class Kind(private val name: String, private val priority: Int) extends Comparable[Kind] {

      override def toString(): String = name

      override def equals(other: Any): Boolean = other match {
        case other: Kind => other.name == this.name
        case _           => false

      }

      override def hashCode(): Int = name.hashCode

      override def compareTo(that: Kind): Int =
        java.lang.Integer.compare(this.priority, that.priority)

    }

  }

  /**
 Container for [[DirectoryWatcher]] events
   */
  class Event(val path: Path, val kind: Event.Kind) {

    override def equals(other: Any): Boolean = other match {
      case other: Event => {
        val that: Event = other
        this.path == that.path && this.kind == that.kind
      }
      case _ => false

    }

    override def hashCode(): Int = path.hashCode ^ kind.hashCode

    override def toString(): String = "Event(" + path + ", " + kind + ")"

  }

  /**
 Options for the DirectoryWatcher.
   */
  class Option(private val name: String) {

    override def equals(obj: Any): Boolean = obj match {
      case obj: Option => obj.name == this.name
      case _           => false

    }

    override def hashCode(): Int = name.hashCode

    override def toString(): String = name

  }

  object Options {

    /**
     * Require that the DirectoryWatcher poll newly created directories for files contained therein.
     * A creation event will be generated for any file found within the new directory. This is
     * somewhat expensive and may be redundant in some cases, see [[FileCache]] which does its
     * own polling for new directories.
     */
    val POLL_NEW_DIRECTORIES: Option = new Option("POLL_NEW_DIRECTORIES")

  }

}

/**
 * Watches directories for file changes. The api permits recursive watching of directories unlike
 * the [[https://docs.oracle.com/javase/7/docs/api/java/nio/file/WatchService.html  java.nio.file.WatchService]]. Some of the behavior may vary by platform due to
 * fundamental differences in the underlying file event apis. For example, Linux doesn't support
 * recursive directory monitoring via inotify, so it's possible in rare cases to miss file events
 * for newly created files in newly created directories. On OSX, it is difficult to disambiguate
 * file creation and modify events, so the [[DirectoryWatcher.Event.Kind]] is best effort, but
 * should not be relied upon to accurately reflect the state of the file.
 */
abstract class DirectoryWatcher extends AutoCloseable {

  /**
   * Register a path to monitor for file events. The watcher will only watch child subdirectories up
   * to maxDepth. For example, with a directory structure like /foo/bar/baz, if we register the path
   * /foo/ with maxDepth 0, we will be notified for any files that are created, updated or deleted
   * in foo, but not bar. If we increase maxDepth to 1, then the files in /foo/bar are monitored,
   * but not the files in /foo/bar/baz.
   *
   * @param path The directory to watch for file events
   * @param maxDepth The maximum maxDepth of subdirectories to watch
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  def register(path: Path, maxDepth: Int): Either[IOException, Boolean]

  /**
   * Register a path to monitor for file events. The monitoring may be recursive.
   *
   * @param path The directory to watch for file events
   * @param recursive Toggles whether or not to monitor subdirectories
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  def register(path: Path, recursive: Boolean): Either[IOException, Boolean] =
    register(path, if (recursive) java.lang.Integer.MAX_VALUE else 0)

  /**
   * Register a path to monitor for file events recursively.
   *
   * @param path The directory to watch for file events
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  def register(path: Path): Either[IOException, Boolean] = register(path, true)

  /**
   * Stop watching a directory
   *
   * @param path The directory to remove from monitoring
   */
  def unregister(path: Path): Unit

  /**
 Catch any exceptions in subclasses.
   */
  override def close(): Unit = {}

}
