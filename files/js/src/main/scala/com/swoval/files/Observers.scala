// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.Directory.Entry
import com.swoval.files.Directory.Observer
import com.swoval.files.Directory.OnChange
import com.swoval.files.Directory.OnError
import com.swoval.files.Directory.OnUpdate
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.HashMap
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.concurrent.atomic.AtomicInteger

/**
 * Container class that wraps multiple [[com.swoval.files.Directory.Observer]] and runs the
 * callbacks for each whenever the [[com.swoval.files.FileCache]] detects an event.
 *
 * @tparam T the data type for the [[com.swoval.files.FileCache]] to which the observers
 *     correspond
 */
class Observers[T] extends Observer[T] with AutoCloseable {

  private val counter: AtomicInteger = new AtomicInteger(0)

  private val observers: Map[Integer, Observer[T]] = new HashMap()

  override def onCreate(newEntry: Entry[T]): Unit = {
    var cbs: List[Observer[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[Observer[T]] = cbs.iterator()
    while (it.hasNext) it.next().onCreate(newEntry)
  }

  override def onDelete(oldEntry: Entry[T]): Unit = {
    var cbs: List[Observer[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[Observer[T]] = cbs.iterator()
    while (it.hasNext) it.next().onDelete(oldEntry)
  }

  override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
    var cbs: List[Observer[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[Observer[T]] = cbs.iterator()
    while (it.hasNext) it.next().onUpdate(oldEntry, newEntry)
  }

  override def onError(path: Path, exception: IOException): Unit = {
    var cbs: List[Observer[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[Observer[T]] = cbs.iterator()
    while (it.hasNext) it.next().onError(path, exception)
  }

  /**
   * Add an observer to receive events.
   *
   * @param observer the new observer
   * @return a handle to the added observer that can be used to halt observation using [[    com.swoval.files.Observers.removeObserver]] .
   */
  def addObserver(observer: Observer[T]): Int = {
    val key: Int = counter.getAndIncrement
    observers.synchronized {
      observers.put(key, observer)
    }
    key
  }

  /**
   * Remove an instance of [[com.swoval.files.Directory.Observer]] that was previously added
   * using [[com.swoval.files.Observers.addObserver]].
   *
   * @param handle the handle to remove
   */
  def removeObserver(handle: Int): Unit = {
    observers.synchronized {
      observers.remove(handle)
    }
  }

  override def close(): Unit = {
    observers.clear()
  }

}
